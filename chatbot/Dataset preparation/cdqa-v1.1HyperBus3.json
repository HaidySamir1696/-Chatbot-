{"data":[{"title":"HyperBus","paragraphs":[{"context":"Address  Space: 'Memory', Byte  Order: 'Little- endian', Byte  Position: 'B', Word  Data  Bit: '10', DQ: '2', Bit Order: 'When data is being accessed in memory space:  The first byte of each word read or written is the \u201cA\u201d byte and the second is the \u201cB\u201d byte.  The bits of the word within the A and B bytes depend on how the data was written. If the  word lower address bits 7-0 are written in the A byte position and bits 15-8 are written into  the B byte position, or vice versa, they will be read back in the same order.  So, memory space can be stored and read in either little-endian or big-endian order.'","qas":[]},{"context":"Address  Space: 'Memory', Byte  Order: 'Little- endian', Byte  Position: 'B', Word  Data  Bit: '9', DQ: '1', Bit Order: 'When data is being accessed in memory space:  The first byte of each word read or written is the \u201cA\u201d byte and the second is the \u201cB\u201d byte.  The bits of the word within the A and B bytes depend on how the data was written. If the  word lower address bits 7-0 are written in the A byte position and bits 15-8 are written into  the B byte position, or vice versa, they will be read back in the same order.  So, memory space can be stored and read in either little-endian or big-endian order.'","qas":[]},{"context":"Address  Space: 'Memory', Byte  Order: 'Little- endian', Byte  Position: 'B', Word  Data  Bit: '8', DQ: '0', Bit Order: 'When data is being accessed in memory space:  The first byte of each word read or written is the \u201cA\u201d byte and the second is the \u201cB\u201d byte.  The bits of the word within the A and B bytes depend on how the data was written. If the  word lower address bits 7-0 are written in the A byte position and bits 15-8 are written into  the B byte position, or vice versa, they will be read back in the same order.  So, memory space can be stored and read in either little-endian or big-endian order.'","qas":[]},{"context":"Document Number: 001-99253 Rev. *B Page 13 of 47","qas":[]},{"context":"Figure 3.3  Data Placement During a Write Transaction","qas":[]},{"context":"Notes:\n1. Figure shows a portion of a Write transaction on the HyperBus.\n2. Data is \u201ccenter aligned\u201d with the clock during a Write transaction.\n3. RWDS functions as a data mask during write data transfers with initial latency. Masking of the first and last byte is shown to illustrate an unaligned 3 byte write of data.\n4. RWDS is not driven by the master during write data transfers with zero initial latency. Full data words are always written in this case. RWDS may be driven low or left","qas":[]},{"context":"High-Z by the slave in this case.","qas":[]},{"context":"3.2 Read Transactions\nThe HyperBus master begins a transaction by driving CS# Low while clock is idle. Then the clock begins toggling while Command-\nAddress CA words are transfered.","qas":[]},{"context":"In CA0, CA[47] = 1 indicates that a Read transaction is to be performed. CA[46] = 0 indicates the memory space is being read or \nCA[46] = 0 indicates the register space is being read. CA[45] indicates the burst type (wrapped or linear). Read transactions can \nbegin the internal array access as soon as the row and upper column address has been presented in CA0 and CA1 (CA[47:16]). \nCA2 (CA(15:0]) identifies the target Word address within the chosen row. However, some HyperBus devices may require a minimum \ntime between the end of a prior transaction and the start of a new access. This time is referred to as Read-Write-Recovery time \n(tRWR). The master interface must start driving CS# Low only at a time when the CA1 transfer will complete after tRWR is satisfied.","qas":[{"question":"what does CA[45] indicate?","id":"9c5ad6f9-6b7f-40c3-98a3-160ade36c547","answers":[{"answer_start":184,"text":"CA[45] indicates the burst type (wrapped or linear)."}]},{"question":"What does tRWR refer to?","id":"c1a0a4ea-c3ed-4d4d-8dbe-f8d4777ec66a","answers":[{"answer_start":466,"text":"some HyperBus devices may require a minimum \ntime between the end of a prior transaction and the start of a new access. This time is referred to as Read-Write-Recovery time \n(tRWR)."}]}]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'A', Word  Data  Bit: '15', DQ: '7', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[{"question":"How many bytes are transferred during a read transaction?","id":"950da317-f270-4cd8-817b-3d126de0e853","answers":[{"answer_start":169,"text":"During a Read transaction on the HyperBus two bytes are transferred on each clock cycle."}]},{"question":"Is register space read in big endian?","id":"e43ca169-2424-437b-af52-ce685eb66bcb","answers":[{"answer_start":642,"text":"register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions."}]}]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'A', Word  Data  Bit: '14', DQ: '6', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'A', Word  Data  Bit: '13', DQ: '5', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'A', Word  Data  Bit: '12', DQ: '4', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'A', Word  Data  Bit: '11', DQ: '3', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'A', Word  Data  Bit: '10', DQ: '2', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'A', Word  Data  Bit: '9', DQ: '1', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'A', Word  Data  Bit: '8', DQ: '0', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'B', Word  Data  Bit: '7', DQ: '7', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'B', Word  Data  Bit: '6', DQ: '6', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'B', Word  Data  Bit: '5', DQ: '5', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'B', Word  Data  Bit: '4', DQ: '4', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'B', Word  Data  Bit: '3', DQ: '3', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'B', Word  Data  Bit: '2', DQ: '2', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'B', Word  Data  Bit: '1', DQ: '1', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Address  Space: 'Register', Byte  Order: 'Big- endian', Byte  Position: 'B', Word  Data  Bit: '0', DQ: '0', Bit Order: 'When data is being accessed in register space:  During a Read transaction on the HyperBus two bytes are transferred on each clock cycle.  The upper order byte A (Word[15:8]) is transferred between the rising and falling edges of  RWDS (edge aligned). The lower order byte B (Word[7:0]) is transferred between the  falling and rising edges of RWDS.  During a write, the upper order byte A (Word[15:8]) is transferred on the CK rising edge  and the lower order byte B (Word[7:0]) is transferred on the CK falling edge. So, register space is always read and written in Big-endian order because registers have  device dependent fixed bit location and meaning definitions.'","qas":[]},{"context":"Document Number: 001-99253 Rev. *B Page 14 of 47","qas":[]},{"context":"The HyperBus master then continues clocking for a number of cycles defined by the latency count setting in a configuration register. \nThe initial latency count required for a particular clock frequency is device dependent - refer to the device data sheet to determine \nthe correct configuration register and initial latency setting for the desired operating frequency. If RWDS is Low during the CA cycles, \none latency count is inserted. If RWDS is High during the CA cycles, an additional latency count is inserted. Once these latency \nclocks have been completed the memory starts to simultaneously transition the Read-Write Data Strobe (RWDS) and output the \ntarget data.","qas":[]},{"context":"New data is output edge aligned with every transition of RWDS. Data will continue to be output as long as the host continues to \ntransition the clock while CS# is Low. However, the HyperBus slave may stop RWDS transitions with RWDS Low, between the \ndelivery of words, in order to insert latency between words when crossing certain memory array boundaries or for other reasons. The \nslave may also hold the RWDS Low for an extended period of 32 or more clocks as an indication of an error condition that requires \nthe read transaction be discontinued by the master. The use of RWDS for insertion of latency between word transfers or to indicate \nerrors is device dependent, refer to individual device data sheets for additional information on if or when this latency insertion \nmethod may be used by a HyperBus device.","qas":[{"question":"When does the slave stop RWDS?","id":"c8a1c278-2b1f-4db8-93f4-b787a961ff9c","answers":[{"answer_start":177,"text":"the HyperBus slave may stop RWDS transitions with RWDS Low, between the \ndelivery of words, in order to insert latency between words when crossing certain memory array boundaries or for other reasons."}]}]},{"context":"Wrapped bursts will continue to wrap within the burst length and linear burst will output data in a sequential manner across row \nboundaries. When a linear burst read reaches the last address in the array, continuing the burst beyond the last address will provide \nundefined data. Read transfers can be ended at any time by bringing CS# High when the clock is idle.","qas":[]},{"context":"The clock is not required to be free-running. The clock may remain idle while CS# is high.","qas":[]},{"context":"Figure 3.4  Read Transaction with Additional Initial Latency","qas":[]},{"context":"Notes:\n1. Transactions are initiated with CS# falling while CK=Low and CK#=High. \n2. CS# must return High before a new transaction is initiated. \n3. CK# is the complement of the CK signal. 3V devices use a single ended clock (CK only), CK# is used with CK on1.8V devices to provide a differential clock. CK# of a","qas":[{"question":"How does a read transaction start?","id":"42d8f384-e8f6-43d9-8641-c0663d32a5b5","answers":[{"answer_start":10,"text":"Transactions are initiated with CS# falling while CK=Low and CK#=High."}]},{"question":"When does chip select return high?","id":"16b20e0f-5c88-4b43-85bc-58ed617e39c7","answers":[{"answer_start":85,"text":"CS# must return High before a new transaction is initiated."}]}]},{"context":"differential clock is shown as a dashed line waveform.\n4. Read access array starts once CA[23:16] is captured.\n5. The read latency is defined by the initial latency value in a configuration register.\n6. In this read transaction example the initial latency count was set to four clocks.\n7. In this read transaction a RWDS High indication during CA delays output of target data by an additional four clocks.\n8. The memory device drives RWDS during read transactions.","qas":[]},{"context":"Document Number: 001-99253 Rev. *B Page 15 of 47","qas":[]},{"context":"Figure 3.5  Read Transaction Without Additional Initial Latency","qas":[]},{"context":"Notes:\n1. RWDS is Low during the CA cycles. In this Read Transaction there is a single initial latency count for read data access because, this read transaction does not begin","qas":[{"question":"Is RWDS signal high during CA cycles?","id":"1920175e-fe51-4bc4-9b02-32fa8d7cf205","answers":[{"answer_start":10,"text":"RWDS is Low during the CA cycles."}]}]},{"context":"at a time when additional latency is required by the slave.","qas":[]},{"context":"3.3 Write Transactions with Initial Latency\nThe HyperBus master begins a transaction by driving CS# Low while clock is idle. Then the clock begins toggling while Command-\nAddress CA words are transfered.","qas":[]},{"context":"In CA0, CA[47] = 0 indicates that a Write transaction is to be performed. CA[46] = 0 indicates the memory space is being written. \nCA[45] indicates the burst type (wrapped or linear). Write transactions can begin the internal array access as soon as the row and \nupper column address has been presented in CA0 and CA1 (CA[47:16]). CA2 (CA(15:0]) identifies the target word address within \nthe chosen row. However, some HyperBus devices may require a minimum time between the end of a prior transaction and the start \nof a new access. This time is referred to as Read-Write-Recovery time (tRWR). The master interface must start driving CS# Low only \nat a time when the CA1 transfer will complete after tRWR is satisfied.","qas":[{"question":"When does the master drive chip select low?","id":"335ab4e1-1315-43ee-9754-73f824d780d5","answers":[{"answer_start":595,"text":"The master interface must start driving CS# Low only \nat a time when the CA1 transfer will complete after tRWR is satisfied."}]}]},{"context":"The HyperBus master then continues clocking for a number of cycles defined by the latency count setting in a configuration register. \nThe initial latency count required for a particular clock frequency is device dependent - refer to the device data sheet to determine \nthe correct configuration register and initial latency setting for the desired operating frequency. If RWDS is Low during the CA cycles, \none latency count is inserted. If RWDS is High during the CA cycles, an additional latency count is inserted. The use for the \nadditional initial latency is device dependent - refer to the device data sheet for more information.","qas":[]},{"context":"Once these latency clocks have been completed the HyperBus master starts to output the target data. Write data is center aligned \nwith the clock edges. The first byte of data in each word is captured by the memory on the rising edge of CK and the second byte is \ncaptured on the falling edge of CK.","qas":[]},{"context":"During the CA clock cycles, RWDS is driven by the memory.","qas":[]},{"context":"During the write data transfers, RWDS is driven by the host master interface as a data mask. When data is being written and RWDS \nis High the byte will be masked and the array will not be altered. When data is being written and RWDS is Low the data will be \nplaced into the array. Because the master is driving RWDS during write data transfers, neither the master nor the slave device are \nable to indicate a need for latency within the data transfer portion of a write transaction. The slave must be able to accept a \ncontinuous burst of write data or require a limit on the length of a write data burst that the slave can accept. The acceptable write \ndata burst length is device dependent - refer to the device data sheet for more information on any burst length limitation.","qas":[]},{"context":"Data will continue to be transferred as long as the HyperBus master continues to transition the clock while CS# is Low. Legacy \nformat wrapped bursts will continue to wrap within the burst length. Hybrid wrap will wrap once then switch to linear burst starting at \nthe next wrap boundary. Linear burst accepts data in a sequential manner across page boundaries. Write transfers can be ended at \nany time by bringing CS# High when the clock is idle.","qas":[]},{"context":"Document Number: 001-99253 Rev. *B Page 16 of 47","qas":[]},{"context":"Some HyperBus devices do not support Legacy or Hybrid wrapped write transactions. This is device dependent behavior - refer to \nthe device data sheet to determine if the device supports wrapped write transactions.","qas":[]},{"context":"When a linear burst write reaches the last address in the memory array space, continuing the burst has device dependent results - \nrefer to the device data sheet for more information.","qas":[]},{"context":"The clock is not required to be free-running. The clock may remain idle while CS# is high.","qas":[]},{"context":"Document Number: 001-99253 Rev. *B Page 17 of 47","qas":[]},{"context":"Figure 3.6  Write Transaction with Additional Initial Latency","qas":[]},{"context":"Notes:\n1. Transactions must be initiated with CK=Low and CK#=High. \n2. CS# must return High before a new transaction is initiated. \n3. During Command-Address, RWDS is driven by the memory and indicates whether additional latency cycles are required.\n4. In this example, RWDS indicates that additional initial latency cycles are required.\n5. At the end of Command-Address cycles the memory stops driving RWDS to allow the host HyperBus master to begin driving RWDS. The master must drive RWDS to","qas":[]},{"context":"a valid Low before the end of the initial latency to provide a data mask preamble period to the slave.\n6. During data transfer, RWDS is driven by the host to indicate which bytes of data should be either masked or loaded into the array.\n7. The figure shows RWDS masking byte A0 and byte B1 to perform an unaligned word write to bytes B0 and A1.","qas":[]},{"context":"Figure 3.7  Write Transaction Without Additional Initial Latency","qas":[]},{"context":"Notes:\n1. During Command-Address, RWDS is driven by the memory and indicates whether additional latency cycles are required.\n2. In this example, RWDS indicates that there is no additional latency required.\n3. At the end of Command-Address cycles the memory stops driving RWDS to allow the host HyperBus master to begin driving RWDS. The master must drive RWDS to","qas":[]},{"context":"a valid Low before the end of the initial latency to provide a data mask preamble period to the slave.\n4. During data transfer, RWDS is driven by the host to indicate which bytes of data should be either masked or loaded into the array.\n5. The figure shows RWDS masking byte A0 and byte B1 to perform an unaligned word write to bytes B0 and A1.","qas":[]},{"context":"Document Number: 001-99253 Rev. *B Page 18 of 47","qas":[]},{"context":"3.4 Write Transactions without Initial Latency\nA Write transaction starts with the first three clock cycles providing the Command/Address information indicating the transaction \ncharacteristics. CA0 may indicate that a Write transaction is to be performed and also indicates the address space and burst type \n(wrapped or linear).","qas":[]},{"context":"Some slave devices may require write transactions with zero latency between the CA cycles and following write data transfers. \nWrites with zero initial latency, do not have a turn around period for RWDS. The slave device will always drive RWDS during the \nCommand-Address period to indicate whether extended latency is required for a transaction that has initial latency. However, the \nRWDS is driven before the slave device has received the first byte of CA i.e. before the slave knows whether the transaction is a \nread or write, to memory space or register space. In the case of a write with zero latency, the RWDS state during the CA period does \nnot affect the initial latency of zero. Since master write data immediately follows the Command-Address period in this case, the slave \nmay continue to drive RWDS Low or may take RWDS to High-Z during write data transfer. The master must not drive RWDS during \nWrites with zero latency. Writes with zero latency do not use RWDS as a data mask function. All bytes of write data are written (full \nword writes). Writes without initial latency are generally used for register space writes but the requirement for writes with zero latency \nis slave device dependent. Writes with zero latency may be required for memory space or register space or neither, depending on \nthe slave device capability.","qas":[]},{"context":"HyperBus master interfaces must provide a configuration setting to support zero initial latency in write transactions for either or both \nMemory Space and Register Space as required by the device being selected by a CS#.","qas":[]},{"context":"The first byte of data in each word is presented on the rising edge of CK and the second byte is presented on the falling edge of CK. \nWrite data is center aligned with the clock inputs. Write transfers can be ended at any time by bringing CS# High when clock is idle. \nThe clock is not required to be free-running.","qas":[{"question":"How are write transfers ended?","id":"eb38b128-9c6a-4093-bd80-ebceb1ac79d7","answers":[{"answer_start":187,"text":"Write transfers can be ended at any time by bringing CS# High when clock is idle."}]}]},{"context":"Because the slave is not driving RWDS as a flow control indication during write data transfers, the slave device is not able to indicate \na need for latency within the data transfer portion of a write transaction. The slave must be able to accept a continuous burst of write \ndata or the master must limit the length of a write data burst to that which the slave can accept. This is device dependent behavior - \nrefer to the device data sheet for more information on any burst length limitation.","qas":[]},{"context":"Legacy format wrapped bursts will continue to wrap within the burst length. Hybrid wrap will wrap once then switch to linear burst \nstarting at the next wrap boundary. Linear burst accepts data in a sequential manner across page boundaries. Some HyperBus \ndevices do not support wrapped write transactions. This is device dependent behavior. Refer to the device data sheet to determine \nif the device supports wrapped write transactions.","qas":[]},{"context":"When a linear burst write reaches the last address in the memory array space, continuing the burst has device dependent results - \nrefer to the device data sheet for more information.","qas":[]},{"context":"Figure 3.8  Write Operation without Initial Latency","qas":[]},{"context":"Document Number: 001-99253 Rev. *B Page 19 of 47","qas":[]},{"context":"4. Memory Space\nWhen CA[46] is 0 a read or write transaction accesses the memory array. The Memory Space address map is device dependent - \nrefer to the device data sheet to determine the device memory space address map.","qas":[]},{"context":"5. Register Space\nWhen CA[46] is 1 a read or write transaction accesses the Register Space. The Register Space map is device dependent - refer to \nthe device data sheet to determine the complete device register space address map.","qas":[]},{"context":"5.1 Device Identification Registers\nThere are HyperBus device information words (registers) that can be read to identify the device manufacturer, the device type, the \ndata capacity if the device is a memory, and other device specific feature parameters.","qas":[]},{"context":"HyperFlash devices are software backward compatible with the Spansion parallel interface GL family flash memories. HyperFlash \ndevices require a command sequence to make the device identification (ID) information visible. This device ID command sequence \nwas referred as the Autoselect Address Space Overlay (ASO) in GL family memories. When the ID command sequence is written to \nthe HyperFlash device, the ID information replaces (overlays) one sector (erase block) of the memory array space. The base \naddress of the block where the ID information appears is set by an address in the in the command sequence. HyperFlash memories \ndo not require selection of the HyperBus Register Address space when writing commands or reading register information.","qas":[]}]}]}